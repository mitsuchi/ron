# simply typed lambda calculus : simple extension : full
use % for newline
use do end for block

op 99 : _ _
op 99 : succ _                   # successor
op 99 : pred _                   # predecessor
op 99 : iszero _                 # zero test
op 99 : fix _                    # fix
op 99 : nil [ _ ]                # empty list
op 99 : cons [ _ ] _ _           # list constructor
op 99 : isnil [ _ ] _            # test for empty list
op 99 : head [ _ ] _             # head of a list
op 99 : tail [ _ ] _             # tail of a list
op 99 : List _                   # type of lists
op 90 : not _
op 90 : X _
op 75 : _ * _                    # product type
op 74 : _ - _
op 74 : _ > _
op 72 : _ = _
op 70 : _ + _                    # sum type
op 70 : ( _ , _ )                # pair
op 68 r : _ , _
op 65 : { _ }                    # record
op 65 : ≺ _ ≻ as _               # variant
op 65 : ≺ _ ≻ => _               # variant case
op 63 : ≺ _ ≻                    # variant
op 60 : _ . _                    # projection
op 55 : _ as _                   # ascription
op 50 : let _ = _ in _
op 50 : λ _ : _ . _
op 50 : if _ then _ else _
op 50 : letrec _ : _ = _ in _        # recursion
op 50 : left _
op 50 : right _
op 50 : case _ of left _ => _ / right _ => _
op 48 r : _ / _                    # case separator
op 45 : case _ of _              # variant case
op 50 : [ _ -> _ ] _
op 40 r : _ -> _
op 30 : _ : _
op 30 : _ \= _
op 25 : _ ; _
op 20 : _ is _
op 15 : _ : _ ∈ _
op 10 : _ ⊢ _ : _
op 10 : _ => _
op 10 : _ --> _
op 10 : free _ in _

syntax do
    t ::=                     # terms
          true                # constant true
        | false               # constant false
        | x                   # variables
        | λ x : T . t         # abstraction value
        | t t                 # application
        | if t then t else t  # conditional
        | 0                   # constant zero
        | succ t              # successor
        | pred t              # predecessor
        | iszero t            # zero test
        | t as T              # ascription
        | unit
        | let x = t in t      # let binding
        | ( t , t )           # pair
        | t . 1               # 1st projection
        | t . 2               # 2nd projection
        | { ts }              # tuple
        | t . n               # tuple projection
        | left t              # sum : tagging left
        | right t             # sum : tagginf right
        | case t of left x => t / right x => t
        | fix t
        | nil [ T ]            # empty list
        | cons [ T ] t t       # list constructor
        | isnil [ T ] t        # test for empty list
        | head [ T ] t         # head of a list
        | tail [ T ] t         # tail of a list
        | { lt }              # record : {a = 1, b = 2}
        | t . l               # label
        | ≺ l = t ≻ as T      # variant tagging
        | case t of cs        # case

    ts ::= φ | t , ts         # list of term
    lt ::= φ | l = t , lt     # list of label = term
    l ::= <atom>              # record label
    n ::= <number>            # 1, 2, 3, ...

    cs ::= φ | ≺ l = x ≻ => t / cs

    v ::=                     # values
          true
        | false
        |  λ x : T . t        # abstraction value
        | nv                  # numeric value
        | unit
        | ( v , v )           # pair value
        | { vs }              # tuple value
        | left v              # sum value : tagging left
        | right v             # sum value : tagging right
        | nil [ T ]           # empty list
        | cons [ T ] v v      # list constructor
        | { lv }              # record value

    vs ::= φ | v , vs         # values
    nv ::=                    # numeric values:
          0                   # zero
        | succ nv             # successor value
    lv ::= φ | l = v , lv     # record values

    # variables
    x ::= a | b | c | d | e | f | g | h | i | j | k | m

    T ::=                # types
          Bool           # type of booleans
        | Nat            # type of natural numbers
        | T -> T         # type of functions
        | Unit           # unit type
        | T * T          # type of products
        | T + T          # type of sums
        | List T         # type of lists
        | { Ts }         # tuple type
        | { lT }         # record type
        | ≺ lT ≻         # variant type

    Ts ::= φ | T , Ts    # list of types
    lT ::= φ | (l : T), lT # record type

    Γ ::=                # contexts
          φ              # empty context
        | Γ, x : T       # term variable binding

    s ::= t           # term
    y ::= x           # variable
    z ::= x           # variable

    S ::= T           # type variable

    # x, y, z : 変数を表すメタ変数：実際の変数は a から n までの1文字
    # t, s    : 項を表すメタ変数
    # S, T    : 型を表すメタ変数
end

# 評価文脈の文法
context syntax do
    E ::=                   
          _ t                  # 適用 s t の形はまず左側の s を簡約する
        | v _                  # 左側が値 v になったら右側を簡約する
        | succ _               # E-Succ
        | pred _               # E-Pred
        | iszero _             # E-IsZero
        | if _ then t else t   # E-If
        | _ as T               # E-Ascribe2
        | let x = _ in t       # E-Let
        | _ . 1                # E-Proj1
        | _ . 2                # E-Proj2
        | ( _ , t )            # E-Pair1 : ペアは左側から評価する
        | ( v , _ )            # E-Pair2 : 左側が値になったら右側へ
        | case _ of left x => t / right x => t
        | left _
        | right _
        | fix _
        | cons [ T ] _ t       # E-Cons1
        | cons [ T ] v _       # E-Cons2
        | isnil [ T ] _        # E-IsNil
        | _ . n                # E-Proj
        | { _ , ts }           # E-Tuple1
        | _ . l                # E-Proj Record
        | case _ of cs         # E-Case
        | ≺ l = _ ≻ as T       # E-Variant
end

# 評価文脈の展開ルール
context rule do
    E [t] -> E [t'] do
        t -> t'
    end
end

# T-Abs
Γ ⊢ (λ x : T1 . t) : T1 -> T2 do
    Γ, x : T1 ⊢ t : T2
end

# T-App
Γ ⊢ t1 t2 : T2 do
    Γ ⊢ t1 : T1 -> T2
    Γ ⊢ t2 : T1
end

# T-Var
Γ ⊢ x : T do
    x : T ∈ Γ
end

# type for x in Γ is T <=> x : T ∈ Γ
x : T ∈ (Γ, x : T)
x : T1 ∈ (Γ, y : T2) do
    <x \= y>
    x : T1 ∈ Γ
end

# 右側が値になったらベータ簡約する
(λ x : T . t) v -> s' do
    [x -> v] t => s'
end

# 簡約の反射推移閉包
t1 --> t2 do
    t1 -> t3
    t3 --> t2
end
t1 --> t2 do
    t1 -> t2
end
t1 --> t1

# ベータ簡約
# [x -> s] t => u で、t の自由な x を s に置き換えると u になる、の意味

# x は x の中で自由なので s に置き換える
[x -> s] x => s
# x と異なる変数 y の中に x はないので y のまま
[x -> s] y => y do
    <x \= y>
end

# t1 t2 は、それぞれの項の中で置き換える
[x -> s] (t1 t2) => t1' t2' do
     [x -> s] t1 => t1'
     [x -> s] t2 => t2'
end

# true と false はそのまま
[x -> s] true => true
[x -> s] false => false

# 0 はそのまま
[x -> s] 0 => 0

# succ t は、t の中で置き換える
[x -> s] (succ t1) => succ t1' do
     [x -> s] t1 => t1'
end

# pred t は、t の中で置き換える
[x -> s] (pred t1) => pred t1' do
     [x -> s] t1 => t1'
end

# iszero t は、t の中で置き換える
[x -> s] (iszero t1) => iszero t1' do
     [x -> s] t1 => t1'
end

# if t1 then t2 else t3 は、各項の中で置き換える
[x -> s] (if t1 then t2 else t3) => if t1' then t2' else t3' do
     [x -> s] t1 => t1'
     [x -> s] t2 => t2'
     [x -> s] t3 => t3'
end
# λx. t1 の中に自由な x はないのでそのまま
[x -> s] (λx : T. t1) => λx : T. t1

# λy. t1 は、t1 の x を s に置き換えたものとしたいが
# s の中に自由な y があると λy. で束縛されて意味か変わってしまうので、
# そんな y がないという条件でそうする
[x -> s] (λy : T. t1) => λy : T. t2 do
    <x \= y>
    <not (free y in s)>
    [x -> s] t1 => t2
end

# λy. t1 で s の中に自由な y があるときは、
# そもそも λy. t1 の中の y を無関係な変数 z に変える
# その際は仮引数の y と t1 の中の自由な y を z に変える
[x -> s] (λy : T. t1) => λz : T. t2 do
    <x \= y>
    free y in s
    X z                  # 新しい変数 z を、以下を満たすように
    <x \= z>             # バックトラックを繰り返して探す
    <y \= z>             # つまり z は x, y や s, t1 の中の自由変数の
    <not (free z in s)>  # どれとも異なる
    <not (free z in t1)> # z の条件ここまで
    [y -> z] t1 => t3
    [x -> s] t3 => t2
end

# free x in t : 項 t に x が自由変数として出現する
free x in x
free x in t1 t2 do
    free x in t1
end
free x in t1 t2 do
    free x in t2
end
free x in λy : T. t do
    <x \= y>
    free x in t
end

# Nat
Γ ⊢ 0 : Nat
Γ ⊢ succ t1 : Nat do
  Γ ⊢ t1 : Nat
end
Γ ⊢ pred t1 : Nat do
  Γ ⊢ t1 : Nat
end
Γ ⊢ iszero t1 : Bool do
  Γ ⊢ t1 : Nat
end

pred 0 -> 0                      # E-PredZero
pred (succ nv) -> nv             # E-PredSucc
iszero 0 -> true                 # E-IsZeroZero
iszero (succ nv) -> false        # E-IsZeroSucc

# Bool

# T-True, T-False
Γ ⊢ true : Bool
Γ ⊢ false : Bool

# T-If
Γ ⊢ if t1 then t2 else t3 : T do
    Γ ⊢ t1 : Bool
    Γ ⊢ t2 : T
    Γ ⊢ t3 : T
end

if true then t2 else t3 -> t2   # E-IfTrue
if false then t2 else t3 -> t3  # E-ifFalse

# E-Ascribe
v as T -> v

# T-Ascribe
Γ ⊢ t as T : T do
    Γ ⊢ t : T
end

# unit -- derived form
# t1 ; t2 は (λ x : Unit. t2) t1 の糖衣構文
# ただし x は t2 の中に自由変数として現れない
(t1 ; t2) --> t3 do
    <not (free x in t2)>
    (λ x : Unit. t2) t1 --> t3
end

# T-Unit
Γ ⊢ unit : Unit

# unit は変数を含まないのでそのまま
[x -> s] unit => unit

# E-LetV
let x = v in t -> s do
    [x -> v] t => s
end

# T-Let
Γ ⊢ let x = t1 in t2 : T2 do
    Γ ⊢ t1 : T1
    Γ, x : T1 ⊢ t2 : T2
end

# Pair : (t1, t2) は、それぞれの項の中で置き換える
[x -> s] (t1, t2) => (t1', t2') do
     [x -> s] t1 => t1'
     [x -> s] t2 => t2'
end

# t . 1 は t の中で置き換える
[x -> s] t . 1 => t' . 1 do
     [x -> s] t => t'
end
[x -> s] t . 2 => t' . 2 do
     [x -> s] t => t'
end

# E-PairBeta
(v1, v2) . 1 -> v1
(v1, v2) . 2 -> v2

# T-Pair
Γ ⊢ (t1, t2) : T1 * T2 do
    Γ ⊢ t1 : T1
    Γ ⊢ t2 : T2
end
# T-Proj (for pairs)
Γ ⊢ (t1, t2) . 1 : T1 do
    Γ ⊢ t1 : T1
end
Γ ⊢ (t1, t2) . 2 : T2 do
    Γ ⊢ t2 : T2
end

# E-CaseLeft
case (left v) of left x1 => t1 / right x2 => t2 -> t3 do
    [x1 -> v] t1 => t3
end
case (right v) of left x1 => t1 / right x2 => t2 -> t3 do
    [x2 -> v] t1 => t3
end

# T-Left
Γ ⊢ left t1 : T1 + T2 do
    Γ ⊢ t1 : T1
end
# T-Right
Γ ⊢ right t2 : T1 + T2 do
    Γ ⊢ t2 : T2
end
# T-Case
Γ ⊢ case t0 of left x1 => t1 / right x2 => t2 : T do
    Γ ⊢ t0 : T1 + T2
    Γ, x1 : T1 ⊢ t1 : T
    Γ, x2 : T2 ⊢ t2 : T
end

# E-Fix
fix (λx : T. t) -> t' do
    [x -> fix (λx : T. t)] t => t'
end

# fix t は、t の中で置き換える
[x -> s] (fix t1) => fix t1' do
     [x -> s] t1 => t1'
end

# letrec : derived form
letrec x : T = t1 in t2 --> t3 do
    let x = fix (λx : T. t1) in t2 --> t3
end

# E-IsNilNil
isnil [S] (nil [T]) -> true

# E-IsNilCons
isnil [S] (cons [T] v1 v2) -> false

# E-HeadCons
head [S] (cons [T] v1 v2) -> v1

# E-TailCons
tail [S] (cons [T] v1 v2) -> v2

# T-Nil
Γ ⊢ nil [T] : List T

# T-Cons1
Γ ⊢ cons [T] t1 t2 : List T do
    Γ ⊢ t1 : T
    Γ ⊢ t2 : List T
end

# T-IsNil
Γ ⊢ isnil [T] t : Bool do
    Γ ⊢ t : List T
end

# T-Head
Γ ⊢ head [T] t : T do
    Γ ⊢ t : List T
end

# T-Tail
Γ ⊢ tail [T] t : List T do
    Γ ⊢ t : List T
end

# E-ProjTuple
{v, vs} . 1 -> v
{v1, vs} . n1 -> v2 do
    <n1 > 1>
    <n2 is n1 - 1>
    {vs} . n2 -> v2
end

# E-Tuple2
{v, ts} -> {v, ts'} do
    {ts} -> {ts'}
end

# T-Tuple
Γ ⊢ {φ} : {φ}
Γ ⊢ {v, vs} : {T, Ts} do
    Γ ⊢ v : T
    Γ ⊢ {vs} : {Ts}
end

# T-Proj
Γ ⊢ {t, ts} . 1 : T do
    Γ ⊢ t : T
end
Γ ⊢ {t, ts} . n1 : T do
    <n1 > 1>
    <n2 is n1 - 1>
    Γ ⊢ {ts} . n2 : T
end

# E-ProjRecord
{l = v, lv} . l -> v
{l1 = v1, lv} . l2 -> v2 do
    <l1 \= l2>
    {lv} . l2 -> v2
end

# E-Rcd
{l = v, lt} -> {l = v, lt'} do
    {lt} -> {lt'}
end
{l = t, lt} -> {l = t', lt} do
    t -> t'
end

# T-Rcd
Γ ⊢ {l = t, lt} : {(l : T), LT} do
    Γ ⊢ t : T
    Γ ⊢ {lt} : {LT}
end

# T-Proj
Γ ⊢ {l = t, lt} . l : T do
    Γ ⊢ t : T
end
Γ ⊢ {l1 = t1, lt} . l2 : T2 do
    <l1 \= l2>
    Γ ⊢ {lt} . l2 : T2
end

# E-CaseVariant
(case (≺l = v≻ as T) of ≺l = x≻ => t / cs) -> t2 do
    [x -> v] t => t2
end
(case (≺l1 = v≻ as T) of ≺l2 = x≻ => t / cs) -> t2 do
    <l1 \= l2>
    (case (≺l1 = v≻ as T) of cs) -> t2
end

# T-Variant
Γ ⊢ (≺l = t≻ as ≺(l : T), lT≻) : ≺(l : T), lT≻ do
    Γ ⊢ t : T
end
Γ ⊢ (≺l1 = t1≻ as ≺(l2 : T2), lT≻) : ≺(l : T), lT≻ do
    <l1 \= l2>
    Γ ⊢ (≺l1 = t1≻ as ≺lT≻) : ≺lT≻
end

# T-Case
Γ ⊢ (case t0 of ≺l1 = x1≻ => t1 / φ) : ≺(l1 : T1'), φ≻ do
    Γ ⊢ t0 : ≺(l1 : T1), lT≻
    Γ, x1 : T1 ⊢ t1 : T1'
end
Γ ⊢ (case t0 of ≺l1 = x1≻ => t1 / cs) : ≺(l1 : T1'), lT≻ do
    Γ ⊢ t0 : ≺(l1 : T1), lT≻
    Γ, x1 : T1 ⊢ t1 : T1'
    Γ ⊢ (case t0 of cs) : ≺(l1 : T1'), lT≻ do
end

main do
    # variant
    φ ⊢ ≺man = true≻ as ≺(age : Nat), (man : Bool), φ≻ : ≺(age : Nat), (man : Bool), φ≻
    φ ⊢ ≺age = 0≻ as ≺(age : Nat), φ≻ : ≺(age : Nat), φ≻
    case ≺age = pred succ 0≻ as ≺(age : Nat), φ≻ of ≺age = a≻ => succ a / φ -> case ≺age = 0≻ as ≺(age : Nat), φ≻ of ≺age = a≻ => succ a / φ
    ≺age = pred succ 0≻ as ≺(age : Nat), φ≻ -> ≺age = 0≻ as ≺(age : Nat), φ≻
    case ≺mouth = 0≻ as ≺(age : Nat), (mounth : Nat), φ≻ of ≺age = a≻ => succ a / ≺mouth = a≻ => succ succ a / φ -> t2
    case ≺age = 0≻ as ≺(age : Nat), φ≻ of ≺age = a≻ => succ a / φ -> t1
    t? case a of ≺age = b≻ => c / ≺man = d≻ => e / φ
    t? case a of ≺age = b≻ => c / φ
    t? case a of φ
    T? ≺(age : Nat), φ≻
    T? ≺φ≻
    t? ≺age = 0≻ as Nat

    # record
    φ ⊢ {age = 0, man = true, φ} . man : Bool
    φ ⊢ {age = 0, man = true, φ} . age : Nat
    φ ⊢ {age = 0, man = true, φ} : {(age : Nat), (man : Bool), φ}
    φ ⊢ {age = 0, φ} : {(age : Nat), φ}
    {age = pred succ 0, φ} . age -> {age = 0, φ} . age
    {age = 0, height = pred succ 0, φ} -> {age = 0, height = 0, φ}
    {age = pred succ 0, φ} -> {age = 0, φ}
    {age = 0, man = true, φ} . man -> true
    {age = 0, man = true, φ} . age -> 0
    T? { (age : Nat), (man : Bool), φ }
    T? { (age : Nat), φ }
    v? { age = 0 , man = true , φ }
    t? { age = 0 , man = true , φ }
    t? { age = 0 , man = true , φ } . age

    # tuple
    φ ⊢ {0, succ 0, true, φ} . 3 : Bool
    φ ⊢ {0, succ 0, true, φ} . 2 : Nat
    φ ⊢ {0, succ 0, true, φ} . 1 : Nat

    φ ⊢ {0, true, φ} : {Nat, Bool, φ}
    φ ⊢ {φ} : {φ}
    {0, pred succ 0, φ} -> {0, 0, φ}
    {pred succ 0, pred succ 0, φ} -> {0, pred succ 0, φ}

    {0, succ 0, true, φ} . 3 -> true
    {0, succ 0, true, φ} . 2 -> succ 0
    {0, succ 0, true, φ} . 1 -> 0

    T? {Nat, Bool, φ}
    T? {φ}
    v? {0, true, succ 0, φ}
    v? {φ}
    t? {0, true, succ 0, φ}
    t? {φ}

    φ ⊢ tail [Nat] (cons [Nat] 0 (nil [Nat])) : List Nat
    φ ⊢ head [Nat] (cons [Nat] 0 (nil [Nat])) : Nat
    φ ⊢ isnil [Nat] (nil [Nat]) : Bool
    φ ⊢ cons [Bool] true (nil [Bool]) : List Bool
    φ ⊢ nil [Bool] : List Bool

    tail [Bool] (cons [Nat] 0 (cons [Nat] 0 0)) --> cons [Nat] 0 0
    head [Bool] (cons [Nat] (succ 0) 0) --> succ 0
    isnil [Bool] (cons [Nat] 0 (succ 0)) --> false
    isnil [Bool] (nil [Nat]) --> true

    φ ⊢ (left 0) : T1 + Nat
    # T1 : Nat

    case (left 0) of left a => succ a / right b => pred b --> v7
    # v = succ 0

    (λa : (Nat * Nat) . (a . 2)) (pred succ 0, pred succ succ 0) --> v6
    # v6 = succ 0

    let f = λa : Bool. a in f true --> v5
    # v5 = true

    (λa: Unit. a) unit ; (λc: Unit. c) (λd: Unit. d) --> v4
    # v4 = λ d : Unit . d

    (λa: Nat. a) (succ 0) as Nat --> v3
    # v3 = succ 0

    if (iszero 0) then pred succ 0 else succ succ 0 --> v2
    # v2 = 0

    (λa : Nat. succ a) (succ (succ 0)) --> v1
    # v1 = succ succ succ 0

    letrec e : (Nat -> Bool) = λm : Nat . if iszero m then true else (if iszero (pred m) then false else e (pred pred m)) in e (succ succ 0) --> v8
    # v8 = true
end