op 99 : _ _
op 90 : not _ 
op 90 : X _
op 50 : & _ . _
op 50 : [ _ -> _ ] _
op 30 : _ \= _
op 10 : _ => _
op 10 : _ -> _
op 10 : no free _ in _
op 10 : free _ in _

syntax {
    t ::=             # terms
          x           # variables
        | & x . t     # abstraction
        | t t         # application
    s ::= t           # term
    x ::= a | b | c | d | e | f | g | h | i | j | k | l | m | n
    y ::= x           # variable
    z ::= x           # variable
}

[x -> s] x => s
[x -> s] y => y {
    <x \= y>
}
[x -> s] (t1 t2) => t1' t2' {
     [x -> s] t1 => t1'
     [x -> s] t2 => t2'
}
[x -> s] (& x . t1) => & x . t1
[x -> s] (& y . t1) => & y . t2 {
    <x \= y>
    <not (free y in s)>
    [x -> s] t1 => t2
}
[x -> s] (& y . t1) => & z . t2 {
    <x \= y>
    free y in s
    X z
    <x \= z>
    <y \= z>
    <not (free z in s)>
    <not (free z in t1)>
    [y -> z] t1 => t4
    [x -> s] t4 => t2
}

free x in x
free x in t1 t2 {
    free x in t1
}
free x in t1 t2 {
    free x in t2
}
free x in & y . t {
    <x \= y>
    free x in t
}

main {
    # [a -> b] (&a. c) => v
    [a -> b] (& b . a) => v
}