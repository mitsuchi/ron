# IMP of the book "the Formal Semantics of Programmming Languages"

op 80 : atom _
op 80 : integer _
op 70 : _ * _
op 60 : _ + _
op 60 : _ - _
op 60 : _ < _
op 40 : _ = _
op 40 : _ := _                   # substitution
op 40 : _ >= _
op 40 : _ \= _                   # not equal
op 40 : _ is _
op 40 : ~ _
op 30 : _ ∧ _                    # logical AND
op 35 : _ : _                    # status delimiter
op 30 : _ , _
op 20 : _ ∨ _                    # logical OR
op 18 : if _ then _ else _
op 16 : while _ do _
op 14 : _ // _                   # command sequence
op 10 : sub _ [ _ / _ ] => _     # status substitution
op 10 : < _ , _ > -> _           # evaluation

syntax {
    a ::= n | X | a + a | a - a | a * a
    b ::= true | false | a = a | a < a | ~ b | b ∧ b | b ∨ b
    c ::= skip | X := a | c // c | if b then c else c | while b do c
    n ::= <integer>
    X ::= <atom>
}

# evaluation of numbers
<n, s> -> n

# evaluation of sums
<a0 + a1, s> -> n {
    <a0, s> -> n0  ;  <a1, s> -> n1  ;  <n is n0 + n1>
}

# evaluation of subtractions
<a0 - a1, s> -> n {
    <a0, s> -> n0  ;  <a1, s> -> n1  ;  <n is n0 - n1>
}

# evaluation of products
<a0 * a1, s> -> n {
    <a0, s> -> n0  ;  <a1, s> -> n1  ;  <n is n0 * n1>
}

# evaluation of boolean expresssions

<true, s> -> true
<false, s> -> false
<a0 = a1, s> -> true {
    <a0, s> -> n0  ;  <a1, s> -> n1  ;  <n0 is n1>
}
<a0 = a1, s> -> false {
    <a0, s> -> n0  ;  <a1, s> -> n1  ;  <n0 \= n1>
}
<a0 < a1, s> -> true {
    <a0, s> -> n0  ;  <a1, s> -> n1  ;  <n0 < n1>
}
<a0 < a1, s> -> false {
    <a0, s> -> n0  ;  <a1, s> -> n1  ;  <n0 >= n1>
}
< ~ b, s> -> true {
    <b, s> -> false
}
< ~ b, s> -> false {
    <b, s> -> true
}
<b0 ∧ b1, s> -> b {
    <b0, s> -> b0'
    <b1, s> -> b1'
    b0' ∧ b1' is b

}
false ∧ false is false
false ∧ true is false
true ∧ false is false
true ∧ true is true

<b0 ∨ b1, s> -> b {
    <b0, s> -> b0'
    <b1, s> -> b1'
    b0' ∨ b1' is b
}
false ∨ false is false
false ∨ true is true
true ∨ false is true
true ∨ true is true

# status and variables
<X, X = v> -> v
<X, s : X = v> -> v
<X, s : y = v'> -> v {
    <atom X>
    <X \= y>
    <X, s> -> v
}

# rules for commands
<skip, s> -> s

<X := a, s1> -> s2 {
    <a, s1> -> m
    sub s1 [m / X] => s2
}

# substitution
sub 0 [m / X] => 0
sub s : X = n [m / X] => s : X = m
sub s1 : X = n [m / y] => s2 : X = n {
    <X \= y>
    sub s1 [m / y] => s2
}

# sequence
<c0 // c1, s1> -> s2 {
    <c0, s1> -> s3
    <c1, s3> -> s2
}

# conditionals
<if b then c0 else c1, s> -> s' {
    <b, s> -> true
    <c0, s> -> s'
}
<if b then c0 else c1, s> -> s' {
    <b, s> -> false
    <c1, s> -> s'
}

# while loops
<while b do c, s> -> s {
    <b, s> -> false
}

<while b do c, s> -> s1 {
    <b, s> -> true
    <c, s> -> s2
    <while b do c, s2> -> s1
}

main {
    <while 0 < p do (q := q + p // p := p - 1), 0 : p = 10 : q = 0> -> v
    # v = 0 : p = 0 : q = 55
}