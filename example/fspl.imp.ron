# IMP of the book "the Formal Semantics of Programmming Languages"

op 80 : atom _
op 80 : integer _
op 70 : _ * _
op 60 : _ + _
op 60 : _ - _
op 60 : _ < _
op 40 : _ = _
op 40 : _ := _                   # substitution
op 40 : _ >= _
op 40 : _ \= _                   # not equal
op 40 : _ is _
op 40 : ~ _
op 30 : _ ∧ _                    # logical AND
op 35 : _ : _                    # state delimiter
op 30 : _ , _
op 20 : _ ∨ _                    # logical OR
op 18 : if _ then _ else _
op 16 : while _ do _
op 14 : _ // _                   # command sequence
op 10 : _ [ _ / _ ] => _         # state update
op 10 : < _ , _ > -> _           # evaluation

syntax {
    a ::= n | X | a + a | a - a | a * a
    b ::= true | false | a = a | a < a | ~ b | b ∧ b | b ∨ b
    c ::= skip | X := a | c // c | if b then c else c | while b do c
    n ::= <integer>
    X ::= <atom>
    constants ::= φ   # empty state
}

# evaluation of numbers
<n, s> -> n

# evaluation of sums
<a0 + a1, s> -> n {
    <a0, s> -> n0  ;  <a1, s> -> n1  ;  <n is n0 + n1>
}

# evaluation of subtractions
<a0 - a1, s> -> n {
    <a0, s> -> n0  ;  <a1, s> -> n1  ;  <n is n0 - n1>
}

# evaluation of products
<a0 * a1, s> -> n {
    <a0, s> -> n0  ;  <a1, s> -> n1  ;  <n is n0 * n1>
}

# evaluation of boolean expresssions
<true, s> -> true
<false, s> -> false

<a0 = a1, s> -> true {
    <a0, s> -> n0  ;  <a1, s> -> n1  ;  <n0 is n1>
}
<a0 = a1, s> -> false {
    <a0, s> -> n0  ;  <a1, s> -> n1  ;  <n0 \= n1>
}
<a0 < a1, s> -> true {
    <a0, s> -> n0  ;  <a1, s> -> n1  ;  <n0 < n1>
}
<a0 < a1, s> -> false {
    <a0, s> -> n0  ;  <a1, s> -> n1  ;  <n0 >= n1>
}
< ~ b, s> -> true {
    <b, s> -> false
}
< ~ b, s> -> false {
    <b, s> -> true
}
<b0 ∧ b1, s> -> b {
    <b0, s> -> b0'
    <b1, s> -> b1'
    b0' ∧ b1' is b

}
false ∧ false is false
false ∧ true is false
true ∧ false is false
true ∧ true is true

<b0 ∨ b1, s> -> b {
    <b0, s> -> b0'
    <b1, s> -> b1'
    b0' ∨ b1' is b
}
false ∨ false is false
false ∨ true is true
true ∨ false is true
true ∨ true is true

# state and variables
<X, X = v> -> v
<X, s : X = v> -> v
<X, s : y = v'> -> v {
    <atom X>
    <X \= y>
    <X, s> -> v
}

# rules for commands
<skip, s> -> s

<X := a, s1> -> s2 {
    <a, s1> -> m
    s1 [m / X] => s2
}

# state update
φ [m / X] => φ
s : X = n [m / X] => s : X = m
s1 : X = n [m / y] => s2 : X = n {
    <X \= y>
    s1 [m / y] => s2
}

# sequence
<c0 // c1, s1> -> s2 {
    <c0, s1> -> s3
    <c1, s3> -> s2
}

# conditionals
<if b then c0 else c1, s> -> s' {
    <b, s> -> true
    <c0, s> -> s'
}
<if b then c0 else c1, s> -> s' {
    <b, s> -> false
    <c1, s> -> s'
}

# while loops
<while b do c, s> -> s {
    <b, s> -> false
}

<while b do c, s> -> s1 {
    <b, s> -> true
    <c, s> -> s2
    <while b do c, s2> -> s1
}

main {
    <while 0 < p do (q := q + p // p := p - 1), φ : p = 10 : q = 0> -> v
    # v = φ : p = 0 : q = 55

    # <c, s> の s の部分は変数の状態を表していて
    # φ なら空の状態
    # φ : p = 0 : q = 55 なら変数 p が 0, q が 55 である状態
}