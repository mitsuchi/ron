# simply typed lambda calculus over booleans

op 99 : _ _
op 50 : λ _ : _ . _
op 50 : if _ then _ else _
op 40 : _ -> _
op 30 : _ : _
op 30 : _ \= _
op 20 : _ , _
op 15 : _ : _ ∈ _
op 10 : _ ⊢ _ : _

syntax {
    t ::=                     # terms
          true                # constant true
        | false               # constant false
        | x                   # variables
        | λ x : T . t         # abstraction value
        | t t                 # application
        | if t then t else t  # conditional

    v ::=                # values
          λ x : T . t    # abstraction value
    
    # variables
    x ::= a | b | c | d | e | f | g | h | i | j | k | l | m | n

    T ::=                # types
          Bool           # type of booleans
        | T -> T         # type of functions

    Γ ::=                # contexts
          φ              # empty context
        | Γ, x : T       # term variable binding
}

Γ ⊢ (λ x : T1 . t) : T1 -> T2 {
    Γ, x : T1 ⊢ t : T2
}

Γ ⊢ t1 t2 : T2 {
    Γ ⊢ t1 : T1 -> T2
    Γ ⊢ t2 : T1
}

Γ ⊢ true : Bool
Γ ⊢ false : Bool

Γ ⊢ x : T {
    x : T ∈ Γ
}

x : T ∈ (Γ, x : T)
x : T1 ∈ (Γ, y : T2) {
    <x \= y>
    x : T1 ∈ Γ
}

Γ ⊢ if t1 then t2 else t3 : T {
    Γ ⊢ t1 : Bool
    Γ ⊢ t2 : T
    Γ ⊢ t3 : T
}

main {
    φ, f : (Bool -> Bool) ⊢ λa : Bool. f (if a then false else a) : T
    # T = Bool -> Bool
}